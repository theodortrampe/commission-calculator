// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
}

// --------------------------------------
// 1. USERS
// --------------------------------------

enum Role {
  ADMIN
  REP
  MANAGER
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  name          String
  role          Role      @default(REP)
  
  // Auth fields
  passwordHash  String?   // null for OAuth-only users
  emailVerified DateTime?
  image         String?
  
  // Hierarchy
  managerId String?
  manager   User?    @relation("ManagerToRep", fields: [managerId], references: [id])
  reports   User[]   @relation("ManagerToRep")

  // Data
  periodData  UserPeriodData[]
  orders      Order[]
  payouts     Payout[]
  adjustments Adjustment[]
  
  // Auth.js relations
  accounts    Account[]
  sessions    Session[]

  createdAt DateTime @default(now())
  @@map("users")
}

// Auth.js Account model (for OAuth providers)
model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

// Auth.js Session model
model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

// --------------------------------------
// 2. PERIOD DATA (The "Rate Source")
// --------------------------------------

model UserPeriodData {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  
  // The "When"
  month       DateTime // 2023-10-01
  
  // The "Input Variables" (Synced from BigQuery)
  title       String?
  quota       Float    // Denominator
  baseSalary  Float    // Subtractor
  ote         Float    // Minuend
  
  // The "Output Variable" (Derived)
  // We store this to prevent historical changes if math logic changes later
  effectiveRate Float  // (OTE - Base) / Quota

  // Relations
  planId      String?
  plan        CompPlan? @relation(fields: [planId], references: [id])

  @@unique([userId, month])
  @@map("user_period_data")
}

// --------------------------------------
// 3. ORDERS
// --------------------------------------

enum OrderStatus {
  APPROVED
  PENDING
  DRAFT
  CANCELLED
}

model Order {
  id             String      @id @default(uuid())
  orderNumber    String      @unique 
  
  // Financials
  convertedUsd   Float
  convertedEur   Float
  
  status         OrderStatus
  bookingDate    DateTime    

  // Relations
  userId         String
  user           User        @relation(fields: [userId], references: [id])
  
  @@map("orders")
}

// --------------------------------------
// 4. LOGIC CONFIG (Accelerators Only)
// --------------------------------------

enum PayoutFreq {
  MONTHLY
  QUARTERLY
}

model CompPlan {
  id          String     @id @default(uuid())
  name        String     // "AE 2024 Accelerator Plan"
  frequency   PayoutFreq
  baseRateMultiplier Float @default(1.0)  // 1x = normal rate
  
  // Feature toggles
  acceleratorsEnabled Boolean @default(true)
  kickersEnabled      Boolean @default(false)
  
  // Logic for what happens AFTER 100% quota
  // e.g. "Over 100% attainment = 1.5x multiplier on the effectiveRate"
  accelerators Json?
  
  // Kickers: fixed % of OTE at attainment milestones
  // e.g. { tiers: [{ attainmentThreshold: 100, kickerPercent: 5 }] }
  kickers Json?

  periodData   UserPeriodData[]

  @@map("comp_plans")
}

// --------------------------------------
// 5. PAYOUTS (Historical Record)
// --------------------------------------
// *Real-time views do NOT query this table. They query Orders + PeriodData directly.*

enum AdjustmentType {
  REVENUE       // Additional bookings $ that flows through commission calculation
  FIXED_BONUS   // Fixed $ bonus added directly to final payout
}

enum PayoutStatus {
  DRAFT
  PUBLISHED
}

model Payout {
  id             String       @id @default(uuid())
  periodStart    DateTime     
  periodEnd      DateTime
  
  grossEarnings  Float        
  finalPayout    Float        
  
  status         PayoutStatus @default(DRAFT)

  userId         String
  user           User         @relation(fields: [userId], references: [id])
  adjustments    Adjustment[] 

  createdAt      DateTime     @default(now())

  @@map("payouts")
}

model Adjustment {
  id             String         @id @default(uuid())
  amount         Float    
  reason         String   
  adjustmentType AdjustmentType @default(FIXED_BONUS)
  
  // Link to user and period (allows adjustments before payout exists)
  userId         String
  user           User           @relation(fields: [userId], references: [id])
  month          DateTime
  
  // Optional link to payout (connected when payout is generated)
  payoutId       String?
  payout         Payout?        @relation(fields: [payoutId], references: [id])
  
  createdAt      DateTime       @default(now())

  @@map("adjustments")
}
