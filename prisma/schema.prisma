// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
}

// --------------------------------------
// 1. USERS
// --------------------------------------

enum Role {
  ADMIN
  REP
  MANAGER
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String
  role      Role     @default(REP)
  
  // Hierarchy
  managerId String?
  manager   User?    @relation("ManagerToRep", fields: [managerId], references: [id])
  reports   User[]   @relation("ManagerToRep")

  // Data
  periodData  UserPeriodData[]
  orders      Order[]
  payouts     Payout[]
  adjustments Adjustment[]

  createdAt DateTime @default(now())
  @@map("users")
}

// --------------------------------------
// 2. PERIOD DATA (The "Rate Source")
// --------------------------------------

model UserPeriodData {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  
  // The "When"
  month       DateTime // 2023-10-01
  
  // The "Input Variables" (Synced from BigQuery)
  title       String?
  quota       Float    // Denominator
  baseSalary  Float    // Subtractor
  ote         Float    // Minuend
  
  // The "Output Variable" (Derived)
  // We store this to prevent historical changes if math logic changes later
  effectiveRate Float  // (OTE - Base) / Quota

  // Relations
  planId      String?
  plan        CompPlan? @relation(fields: [planId], references: [id])

  @@unique([userId, month])
  @@map("user_period_data")
}

// --------------------------------------
// 3. ORDERS
// --------------------------------------

enum OrderStatus {
  APPROVED
  PENDING
  DRAFT
  CANCELLED
}

model Order {
  id             String      @id @default(uuid())
  orderNumber    String      @unique 
  
  // Financials
  convertedUsd   Float
  convertedEur   Float
  
  status         OrderStatus
  bookingDate    DateTime    

  // Relations
  userId         String
  user           User        @relation(fields: [userId], references: [id])
  
  @@map("orders")
}

// --------------------------------------
// 4. LOGIC CONFIG (Accelerators Only)
// --------------------------------------

enum PayoutFreq {
  MONTHLY
  QUARTERLY
}

model CompPlan {
  id          String     @id @default(uuid())
  name        String     // "AE 2024 Accelerator Plan"
  frequency   PayoutFreq
  baseRateMultiplier Float @default(1.0)  // 1x = normal rate
  
  // Feature toggles
  acceleratorsEnabled Boolean @default(true)
  kickersEnabled      Boolean @default(false)
  
  // Logic for what happens AFTER 100% quota
  // e.g. "Over 100% attainment = 1.5x multiplier on the effectiveRate"
  accelerators Json?
  
  // Kickers: fixed % of OTE at attainment milestones
  // e.g. { tiers: [{ attainmentThreshold: 100, kickerPercent: 5 }] }
  kickers Json?

  periodData   UserPeriodData[]

  @@map("comp_plans")
}

// --------------------------------------
// 5. PAYOUTS (Historical Record)
// --------------------------------------
// *Real-time views do NOT query this table. They query Orders + PeriodData directly.*

enum AdjustmentType {
  REVENUE       // Additional bookings $ that flows through commission calculation
  FIXED_BONUS   // Fixed $ bonus added directly to final payout
}

enum PayoutStatus {
  DRAFT
  PUBLISHED
}

model Payout {
  id             String       @id @default(uuid())
  periodStart    DateTime     
  periodEnd      DateTime
  
  grossEarnings  Float        
  finalPayout    Float        
  
  status         PayoutStatus @default(DRAFT)

  userId         String
  user           User         @relation(fields: [userId], references: [id])
  adjustments    Adjustment[] 

  createdAt      DateTime     @default(now())

  @@map("payouts")
}

model Adjustment {
  id             String         @id @default(uuid())
  amount         Float    
  reason         String   
  adjustmentType AdjustmentType @default(FIXED_BONUS)
  
  // Link to user and period (allows adjustments before payout exists)
  userId         String
  user           User           @relation(fields: [userId], references: [id])
  month          DateTime
  
  // Optional link to payout (connected when payout is generated)
  payoutId       String?
  payout         Payout?        @relation(fields: [payoutId], references: [id])
  
  createdAt      DateTime       @default(now())

  @@map("adjustments")
}
